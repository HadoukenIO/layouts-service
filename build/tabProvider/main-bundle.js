/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/provider/tabbing/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/uuid/index.js":
/*!************************************!*\
  !*** ./node_modules/uuid/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var v1 = __webpack_require__(/*! ./v1 */ \"./node_modules/uuid/v1.js\");\nvar v4 = __webpack_require__(/*! ./v4 */ \"./node_modules/uuid/v4.js\");\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n\n\n//# sourceURL=webpack:///./node_modules/uuid/index.js?");

/***/ }),

/***/ "./node_modules/uuid/lib/bytesToUuid.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/bytesToUuid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([bth[buf[i++]], bth[buf[i++]], \n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]]]).join('');\n}\n\nmodule.exports = bytesToUuid;\n\n\n//# sourceURL=webpack:///./node_modules/uuid/lib/bytesToUuid.js?");

/***/ }),

/***/ "./node_modules/uuid/lib/rng-browser.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/rng-browser.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n// implementation. Also, find the complete implementation of crypto on IE11.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\n\n//# sourceURL=webpack:///./node_modules/uuid/lib/rng-browser.js?");

/***/ }),

/***/ "./node_modules/uuid/v1.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v1.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var rng = __webpack_require__(/*! ./lib/rng */ \"./node_modules/uuid/lib/rng-browser.js\");\nvar bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ \"./node_modules/uuid/lib/bytesToUuid.js\");\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\nvar _clockseq;\n\n// Previous uuid creation time\nvar _lastMSecs = 0;\nvar _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n  if (node == null || clockseq == null) {\n    var seedBytes = rng();\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [\n        seedBytes[0] | 0x01,\n        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]\n      ];\n    }\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  }\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n\n\n//# sourceURL=webpack:///./node_modules/uuid/v1.js?");

/***/ }),

/***/ "./node_modules/uuid/v4.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v4.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var rng = __webpack_require__(/*! ./lib/rng */ \"./node_modules/uuid/lib/rng-browser.js\");\nvar bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ \"./node_modules/uuid/lib/bytesToUuid.js\");\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n\n//# sourceURL=webpack:///./node_modules/uuid/v4.js?");

/***/ }),

/***/ "./src/provider/tabbing/DragWindowManager.ts":
/*!***************************************************!*\
  !*** ./src/provider/tabbing/DragWindowManager.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst asyncWindow_1 = __webpack_require__(/*! ./asyncWindow */ \"./src/provider/tabbing/asyncWindow.ts\");\r\n/**\r\n * Handles the Drag Window which appears when API drag and drop is initialized.\r\n */\r\nclass DragWindowManager extends asyncWindow_1.AsyncWindow {\r\n    constructor() {\r\n        super();\r\n    }\r\n    /**\r\n     * Initializes Async Methods required by this class.\r\n     */\r\n    init() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this._createDragWindow();\r\n        });\r\n    }\r\n    /**\r\n     * Shows the drag window overlay.\r\n     */\r\n    show() {\r\n        this._window.show();\r\n        this._hideTimeout = setTimeout(() => {\r\n            this.hide();\r\n        }, 15000);\r\n    }\r\n    /**\r\n     * Hides the drag window overlay.\r\n     */\r\n    hide() {\r\n        this._window.hide();\r\n        clearTimeout(this._hideTimeout);\r\n    }\r\n    /**\r\n     * Creates the drag overlay window.\r\n     */\r\n    _createDragWindow() {\r\n        return new Promise((res, rej) => {\r\n            this._window = new fin.desktop.Window({\r\n                name: \"TabbingDragWindow\",\r\n                url: \"http://localhost:1337/service/drag.html\",\r\n                defaultHeight: 1,\r\n                defaultWidth: 1,\r\n                defaultLeft: 0,\r\n                defaultTop: 0,\r\n                saveWindowState: false,\r\n                autoShow: true,\r\n                opacity: 0.01,\r\n                frame: false,\r\n                waitForPageLoad: false,\r\n                alwaysOnTop: true,\r\n                showTaskbarIcon: false,\r\n                // @ts-ignore smallWidnow flag is valid\r\n                smallWindow: true\r\n            }, () => {\r\n                this._window.resizeTo(screen.width, screen.height, \"top-left\");\r\n                this._window.hide();\r\n                res();\r\n            }, rej);\r\n        });\r\n    }\r\n}\r\nexports.DragWindowManager = DragWindowManager;\r\n\n\n//# sourceURL=webpack:///./src/provider/tabbing/DragWindowManager.ts?");

/***/ }),

/***/ "./src/provider/tabbing/EventHandler.ts":
/*!**********************************************!*\
  !*** ./src/provider/tabbing/EventHandler.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst APITypes_1 = __webpack_require__(/*! ../../shared/APITypes */ \"./src/shared/APITypes.ts\");\r\nconst TabUtilities_1 = __webpack_require__(/*! ./TabUtilities */ \"./src/provider/tabbing/TabUtilities.ts\");\r\n/**\r\n * @class Handles events coming from the application\r\n */\r\nclass EventHandler {\r\n    /**\r\n     * Constructor for the Event handler class\r\n     * @param {TabService} service Tab service\r\n     */\r\n    constructor(service) {\r\n        this._service = service;\r\n        this._createListeners();\r\n    }\r\n    /**\r\n     * Subscribes to topics and handles messages coming into those topics\r\n     */\r\n    _createListeners() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            fin.desktop.InterApplicationBus.subscribe(\"*\", APITypes_1.AppApiEvents.CLIENTINIT, this._onClientInit.bind(this));\r\n            fin.desktop.InterApplicationBus.subscribe(\"*\", APITypes_1.AppApiEvents.DEREGISTER, this._onClientDeregister.bind(this));\r\n            fin.desktop.System.addEventListener(\"monitor-info-changed\", this._onMonitorInfoChanged.bind(this));\r\n        });\r\n    }\r\n    /**\r\n     * For each group tab we realign all the apps when there is a change in monitor information\r\n     */\r\n    _onMonitorInfoChanged() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._service.tabGroups.forEach((group) => {\r\n                group.realignApps();\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Initialises tabbing on the application\r\n     * @param message TabWindowOptions\r\n     * @param uuid The uuid of the application to initialise tabbing on\r\n     * @param name The name of the application to initialise tabbing on\r\n     */\r\n    _onClientInit(message, uuid, name) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            TabUtilities_1.initializeTabbing(message, uuid, name, this._service);\r\n        });\r\n    }\r\n    /**\r\n     * Deregisters the window from tabbing.\r\n     * @param {} message None.\r\n     * @param {string} uuid The uuid of the application to deregister.\r\n     * @param {string} name The name of the application to deregister.\r\n     */\r\n    _onClientDeregister(message, uuid, name) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const tabGroup = this._service.getTabGroupByApp({ uuid, name });\r\n            if (tabGroup) {\r\n                tabGroup.deregisterTab({ uuid, name });\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.EventHandler = EventHandler;\r\n\n\n//# sourceURL=webpack:///./src/provider/tabbing/EventHandler.ts?");

/***/ }),

/***/ "./src/provider/tabbing/GroupWindow.ts":
/*!*********************************************!*\
  !*** ./src/provider/tabbing/GroupWindow.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst asyncWindow_1 = __webpack_require__(/*! ./asyncWindow */ \"./src/provider/tabbing/asyncWindow.ts\");\r\nconst TabService_1 = __webpack_require__(/*! ./TabService */ \"./src/provider/tabbing/TabService.ts\");\r\n/**\r\n * Handles the window for the Tab-Set\r\n */\r\nclass GroupWindow extends asyncWindow_1.AsyncWindow {\r\n    /**\r\n     * Constructor for the GroupWindow Class.\r\n     * @param windowOptions Window Options for creating the tab set.\r\n     * @param tabGroup The tab group to which this window belongs.\r\n     */\r\n    constructor(windowOptions, tabGroup) {\r\n        super();\r\n        /**\r\n         * Used to store the window bounds before a maximized is called.\r\n         */\r\n        this._beforeMaximizeBounds = {};\r\n        /**\r\n         * Flag for if the window is maximized.\r\n         */\r\n        this._isMaximized = false;\r\n        /**\r\n         * Handle to the Tab service.\r\n         */\r\n        this._service = TabService_1.TabService.INSTANCE;\r\n        this._tabGroup = tabGroup;\r\n        const windowOptionsSanitized = {\r\n            url: windowOptions.url || \"http://localhost:1337/tab-ui/\",\r\n            width: windowOptions.width && !isNaN(windowOptions.width) ? windowOptions.width : undefined,\r\n            height: windowOptions.height && !isNaN(windowOptions.height) ? windowOptions.height : 62,\r\n            screenX: windowOptions.screenX && !isNaN(windowOptions.screenX) ? windowOptions.screenX : undefined,\r\n            screenY: windowOptions.screenY && !isNaN(windowOptions.screenY) ? windowOptions.screenY : undefined\r\n        };\r\n        this._initialWindowOptions = windowOptionsSanitized;\r\n    }\r\n    /**\r\n     * Initialized Async methods for the GroupWindow class.\r\n     */\r\n    init() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._window = yield this._createTabWindow();\r\n            this._createWindowEventListeners();\r\n        });\r\n    }\r\n    /**\r\n     * Aligns this tab set window on top of a provided window.\r\n     * @param app Window to align this tab set window to.\r\n     */\r\n    alignPositionToApp(app) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const win = app.finWindow;\r\n            const bounds = yield app.getWindowBounds();\r\n            const resizeTo = this._window.resizeTo(bounds.width, this._initialWindowOptions.height, \"top-left\");\r\n            const moveTo = this._window.moveTo(bounds.left, bounds.top - this._initialWindowOptions.height);\r\n            yield Promise.all([resizeTo, moveTo]);\r\n            win.joinGroup(this._window);\r\n        });\r\n    }\r\n    /**\r\n     * Toggles the window to a maximized state.  If the window is maximized we will restore it, if not we will maximize it.\r\n     */\r\n    toggleMaximize() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this._isMaximized) {\r\n                return this.restoreGroup();\r\n            }\r\n            else {\r\n                return this.maximizeGroup();\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Maximizes the tab set window.  This will resize the tab window to as large as possible with the tab set window on top.\r\n     */\r\n    maximizeGroup() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._beforeMaximizeBounds = yield this._tabGroup.activeTab.window.getWindowBounds();\r\n            const moveto = this.moveTo(0, 0);\r\n            const tabresizeto = this._tabGroup.activeTab.window.resizeTo(screen.availWidth, screen.availHeight - this._initialWindowOptions.height, \"top-left\");\r\n            yield Promise.all([moveto, tabresizeto]);\r\n            this._isMaximized = true;\r\n        });\r\n    }\r\n    /**\r\n     * Restores the tab set window.  If the tab set window is in a maximized state we will restore the window to its \"before maximized\" bounds.\r\n     */\r\n    restoreGroup() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this._isMaximized) {\r\n                if ((yield this.getState()) === \"minimized\") {\r\n                    this._window.restore();\r\n                    return;\r\n                }\r\n                else {\r\n                    const resize = this._tabGroup.activeTab.window.resizeTo(this._beforeMaximizeBounds.width, this._beforeMaximizeBounds.height, \"top-left\");\r\n                    const moveto = this._tabGroup.window.moveTo(this._beforeMaximizeBounds.left, this._beforeMaximizeBounds.top);\r\n                    this._isMaximized = false;\r\n                    return Promise.all([resize, moveto]);\r\n                }\r\n            }\r\n            else {\r\n                return this._window.restore();\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Minimizes the tab set window and all tab windows.\r\n     */\r\n    minimizeGroup() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const minWins = this._tabGroup.tabs.map(tab => {\r\n                return tab.window.minimize();\r\n            });\r\n            const group = this._window.minimize();\r\n            return Promise.all([minWins, group]);\r\n        });\r\n    }\r\n    /**\r\n     * Closes the tab set window and all its apps.\r\n     */\r\n    closeGroup() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this._service.removeTabGroup(this._tabGroup.ID, true);\r\n        });\r\n    }\r\n    /**\r\n     * Creates event listeners for the tab set window.\r\n     */\r\n    _createWindowEventListeners() {\r\n        this._window.addEventListener(\"focused\", () => {\r\n            this._tabGroup.activeTab.window.finWindow.bringToFront();\r\n        });\r\n        this._window.addEventListener(\"closed\", () => {\r\n            if (this._tabGroup.tabs.length > 0) {\r\n                this._tabGroup.removeAllTabs(true);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Returns the maximized state\r\n     * @returns {boolean} is Maximized?\r\n     */\r\n    get isMaximized() {\r\n        return this._isMaximized;\r\n    }\r\n    /**\r\n     * Sets the is Maximized flag.\r\n     */\r\n    set isMaximized(maximized) {\r\n        this._isMaximized = maximized;\r\n    }\r\n    /**\r\n     * Creates the tab set window using the window options passed in during initialization.\r\n     */\r\n    _createTabWindow() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // @ts-ignore TS complains, but verified this is real and working.\r\n            return new Promise((res, rej) => {\r\n                const win = new fin.desktop.Window({\r\n                    name: this._tabGroup.ID,\r\n                    url: this._initialWindowOptions.url,\r\n                    autoShow: false,\r\n                    frame: false,\r\n                    maximizable: false,\r\n                    resizable: false,\r\n                    defaultHeight: this._initialWindowOptions.height,\r\n                    defaultWidth: this._initialWindowOptions.width,\r\n                    defaultLeft: this._initialWindowOptions.screenX,\r\n                    defaultTop: this._initialWindowOptions.screenY,\r\n                    defaultCentered: !this._initialWindowOptions.screenX && !this._initialWindowOptions.screenY,\r\n                    saveWindowState: false,\r\n                    showTaskbarIcon: false\r\n                }, () => {\r\n                    res(win);\r\n                }, e => {\r\n                    rej(e);\r\n                });\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Returns the initial window options provided during initialization.\r\n     * @returns {TabWindowOptions} TabWindowOptions\r\n     */\r\n    get initialWindowOptions() {\r\n        return this._initialWindowOptions;\r\n    }\r\n}\r\nexports.GroupWindow = GroupWindow;\r\n\n\n//# sourceURL=webpack:///./src/provider/tabbing/GroupWindow.ts?");

/***/ }),

/***/ "./src/provider/tabbing/SaveAndRestoreAPIProcessor.ts":
/*!************************************************************!*\
  !*** ./src/provider/tabbing/SaveAndRestoreAPIProcessor.ts ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst APITypes_1 = __webpack_require__(/*! ../../shared/APITypes */ \"./src/shared/APITypes.ts\");\r\n/**\r\n * Handles all calls from tab api to service\r\n */\r\nclass SaveAndRestoreAPIProcessor {\r\n    /**\r\n     * @constructor Constructor for the SaveAndRestoreAPIProcessor\r\n     */\r\n    constructor(service) {\r\n        this.mTabService = service;\r\n    }\r\n    /**\r\n     * Initialises the SaveAndRestoreAPIProcessor\r\n     */\r\n    init() {\r\n        fin.desktop.InterApplicationBus.subscribe(\"*\", \"SAR-API\", this.process.bind(this));\r\n    }\r\n    /**\r\n     * Processes incoming API messages from the Tab API.\r\n     * @param message The payload the tab api sent\r\n     * @param uuid uuid of the sender\r\n     * @param name name of the sender\r\n     */\r\n    process(message, uuid, name) {\r\n        switch (message.action) {\r\n            case APITypes_1.SaveAndRestoreActions.GETBLOB: {\r\n                this._onGetBlob(uuid, name);\r\n                break;\r\n            }\r\n            default:\r\n                console.error(message.action, \" Not Implemented!\");\r\n                break;\r\n        }\r\n    }\r\n    /**\r\n     * Gathers information from tab sets and their tabs, and returns as a JSON object back to the requesting application/window.\r\n     * @param uuid Uuid of the requesting Application\r\n     * @param name Name of the requesting window\r\n     */\r\n    _onGetBlob(uuid, name) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const tabBlobs = yield Promise.all(this.mTabService.tabGroups.map((group) => __awaiter(this, void 0, void 0, function* () {\r\n                const tabs = group.tabs.map((tab) => {\r\n                    return tab.ID;\r\n                });\r\n                const [groupBounds, appBounds] = yield Promise.all([group.window.getWindowBounds(), group.activeTab.window.getWindowBounds()]);\r\n                const groupInfo = {\r\n                    url: group.window.initialWindowOptions.url,\r\n                    active: group.activeTab.ID,\r\n                    dimensions: {\r\n                        x: groupBounds.left,\r\n                        y: groupBounds.top,\r\n                        width: groupBounds.width,\r\n                        setHeight: groupBounds.height,\r\n                        appHeight: appBounds.height\r\n                    }\r\n                };\r\n                return { tabs, groupInfo };\r\n            })));\r\n            fin.desktop.InterApplicationBus.send(uuid, name, APITypes_1.SaveAndRestoreEvents.GETBLOBRETURN, tabBlobs);\r\n        });\r\n    }\r\n}\r\nexports.SaveAndRestoreAPIProcessor = SaveAndRestoreAPIProcessor;\r\n\n\n//# sourceURL=webpack:///./src/provider/tabbing/SaveAndRestoreAPIProcessor.ts?");

/***/ }),

/***/ "./src/provider/tabbing/Tab.ts":
/*!*************************************!*\
  !*** ./src/provider/tabbing/Tab.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst APITypes_1 = __webpack_require__(/*! ../../shared/APITypes */ \"./src/shared/APITypes.ts\");\r\nconst TabWindow_1 = __webpack_require__(/*! ./TabWindow */ \"./src/provider/tabbing/TabWindow.ts\");\r\n/**\r\n * The Tab class handles functionality related to the tab itself.\r\n */\r\nclass Tab {\r\n    /**\r\n     * Constructor for the Tab Class.\r\n     * @param {TabPackage} tabPackage The tab package contains the uuid, name, and any properties for the tab.\r\n     * @param {TabGroup} tabGroup The tab group to which this tab belongs.\r\n     */\r\n    constructor(tabPackage, tabGroup) {\r\n        /**\r\n         * The properties (title, icon) for the tab.\r\n         */\r\n        this._tabProperties = {};\r\n        this._tabID = tabPackage.tabID;\r\n        this._tabGroup = tabGroup;\r\n        if (tabPackage.tabProps) {\r\n            this._tabProperties = tabPackage.tabProps;\r\n        }\r\n        this._tabWindow = new TabWindow_1.TabWindow(this, tabPackage.tabID);\r\n    }\r\n    /**\r\n     * Initalizes Async methods required for the Tab Class.\r\n     */\r\n    init() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this._tabWindow.init();\r\n            this._tabProperties = this._loadTabProperties();\r\n            fin.desktop.InterApplicationBus.send(fin.desktop.Application.getCurrent().uuid, this._tabGroup.ID, APITypes_1.TabApiEvents.TABADDED, { tabID: this.ID, tabProps: this._tabProperties });\r\n            fin.desktop.InterApplicationBus.send(this.ID.uuid, this.ID.name, APITypes_1.AppApiEvents.TABBED, { tabGroupID: this._tabGroup.ID });\r\n        });\r\n    }\r\n    /**\r\n     * Remove the Tab from the group and possibly its window.\r\n     * @param closeApp Flag if we should close the tabs window.\r\n     */\r\n    remove(closeApp) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._tabWindow.leaveGroup();\r\n            if (closeApp) {\r\n                yield this._tabWindow.close(false);\r\n            }\r\n            fin.desktop.InterApplicationBus.send(fin.desktop.Application.getCurrent().uuid, this._tabGroup.ID, APITypes_1.TabApiEvents.TABREMOVED, this._tabID);\r\n            fin.desktop.InterApplicationBus.send(this.ID.uuid, this.ID.name, APITypes_1.AppApiEvents.UNTABBED, { tabGroupID: this._tabGroup.ID });\r\n        });\r\n    }\r\n    /**\r\n     * Updates the Tab properties with the passed values.\r\n     * @param {TabProperties} props The tab properties to update.\r\n     */\r\n    updateTabProperties(props) {\r\n        this._tabProperties = Object.assign({}, this._tabProperties, props);\r\n        fin.desktop.InterApplicationBus.send(fin.desktop.Application.getCurrent().uuid, this._tabGroup.ID, APITypes_1.TabApiEvents.PROPERTIESUPDATED, { tabID: this.ID, tabProps: props });\r\n        this._saveTabProperties();\r\n    }\r\n    /**\r\n     * Saves the current Tab properties to the localstorage.\r\n     */\r\n    _saveTabProperties() {\r\n        localStorage.setItem(JSON.stringify(this._tabID), JSON.stringify(this._tabProperties));\r\n    }\r\n    /**\r\n     * Loads the Tab properties from the localstorage.\r\n     * @returns {TabProperties} TabProperties\r\n     */\r\n    _loadTabPropertiesFromStorage() {\r\n        const props = localStorage.getItem(JSON.stringify(this._tabID));\r\n        if (props) {\r\n            return JSON.parse(props);\r\n        }\r\n        else {\r\n            return {};\r\n        }\r\n    }\r\n    /**\r\n     * Returns a complete TabProperties set loaded from localstorage + default values.\r\n     * @returns {TabProperties} TabProperties\r\n     */\r\n    _loadTabProperties() {\r\n        const windowOptions = this._tabWindow.windowOptions;\r\n        const storageProps = this._loadTabPropertiesFromStorage();\r\n        const windowIcon = windowOptions.icon && windowOptions.icon.length > 0 ? windowOptions.icon : `https://www.google.com/s2/favicons?domain=${windowOptions.url}`;\r\n        return {\r\n            icon: this._tabProperties.icon || storageProps.icon || windowIcon,\r\n            title: this._tabProperties.title || storageProps.title || windowOptions.name\r\n        };\r\n    }\r\n    /**\r\n     * Returns this Tabs Tab Set.\r\n     * @returns {TabGroup} TabGroup\r\n     */\r\n    get tabGroup() {\r\n        return this._tabGroup;\r\n    }\r\n    /**\r\n     * Returns this Tabs window.\r\n     * @returns {TabWindow} TabWindow\r\n     */\r\n    get window() {\r\n        return this._tabWindow;\r\n    }\r\n    /**\r\n     * Returns this Tabs ID.\r\n     * @returns {TabIdentifier} ID\r\n     */\r\n    get ID() {\r\n        return this._tabID;\r\n    }\r\n}\r\nexports.Tab = Tab;\r\n\n\n//# sourceURL=webpack:///./src/provider/tabbing/Tab.ts?");

/***/ }),

/***/ "./src/provider/tabbing/TabAPIActionProcessor.ts":
/*!*******************************************************!*\
  !*** ./src/provider/tabbing/TabAPIActionProcessor.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst APITypes_1 = __webpack_require__(/*! ../../shared/APITypes */ \"./src/shared/APITypes.ts\");\r\nconst TabUtilities_1 = __webpack_require__(/*! ./TabUtilities */ \"./src/provider/tabbing/TabUtilities.ts\");\r\n/**\r\n * Handles all calls from tab api to service\r\n */\r\nclass TabAPIActionProcessor {\r\n    /**\r\n     * @constructor Constructor for the TabAPIActionProcessor\r\n     */\r\n    constructor(service) {\r\n        this.mTabService = service;\r\n    }\r\n    /**\r\n     * Initialises the TabAPIActionProcessor\r\n     */\r\n    init() {\r\n        fin.desktop.InterApplicationBus.subscribe(\"*\", \"tab-api\", this.process.bind(this));\r\n    }\r\n    /**\r\n     * Processes incoming API messages from the Tab API.\r\n     * @param message The payload the tab api sent\r\n     * @param uuid uuid of the sender\r\n     * @param name name of the sender\r\n     */\r\n    process(message, uuid, name) {\r\n        const tabGroup = this.mTabService.getTabGroup(name);\r\n        console.log(message);\r\n        if (!tabGroup) {\r\n            console.error(\"No tab group has been found wit hthe name\");\r\n            return;\r\n        }\r\n        switch (message.action) {\r\n            case APITypes_1.TabAPIActions.ADD:\r\n                this._add(message, tabGroup);\r\n                break;\r\n            case APITypes_1.TabAPIActions.EJECT:\r\n                this._eject(message, tabGroup);\r\n                break;\r\n            case APITypes_1.TabAPIActions.CLOSE:\r\n                this._close(message, tabGroup);\r\n                break;\r\n            case APITypes_1.TabAPIWindowActions.MAXIMIZE:\r\n                tabGroup.window.maximizeGroup();\r\n                break;\r\n            case APITypes_1.TabAPIWindowActions.MINIMIZE:\r\n                tabGroup.window.minimizeGroup();\r\n                break;\r\n            case APITypes_1.TabAPIWindowActions.CLOSE:\r\n                tabGroup.window.closeGroup();\r\n                break;\r\n            case APITypes_1.TabAPIWindowActions.RESTORE:\r\n                tabGroup.window.restoreGroup();\r\n                break;\r\n            case APITypes_1.TabAPIActions.ACTIVATE:\r\n                this._activate(message, tabGroup);\r\n                break;\r\n            case APITypes_1.TabAPIActions.UPDATEPROPERTIES:\r\n                this._updateTabProperties(message, tabGroup);\r\n                break;\r\n            case APITypes_1.TabAPIActions.STARTDRAG:\r\n                this._startDrag();\r\n                break;\r\n            case APITypes_1.TabAPIActions.ENDDRAG:\r\n                this._endDrag(message, tabGroup);\r\n                break;\r\n            case APITypes_1.TabAPIWindowActions.TOGGLEMAXIMIZE:\r\n                tabGroup.window.toggleMaximize();\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n    /**\r\n     * Starts the drag window process & shows the drag window overlay.\r\n     */\r\n    _startDrag() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.mTabService.dragWindowManager.show();\r\n        });\r\n    }\r\n    /**\r\n     * Ends the drag window process & hides the drag window overlay.\r\n     * @param {{}}message None.\r\n     * @param {TabGroup} group The TabGroup attached to this Tab.\r\n     */\r\n    _endDrag(message, group) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!message.event) {\r\n                console.warn(\"No drag event passed. Cancelling eject\");\r\n                return;\r\n            }\r\n            if (!message.uuid || !message.name) {\r\n                console.error(\"No valid tabID has been passed in\");\r\n                return;\r\n            }\r\n            this.mTabService.dragWindowManager.hide();\r\n            TabUtilities_1.ejectTab(this.mTabService, { uuid: message.uuid, name: message.name, screenX: message.event.screenX, screenY: message.event.screenY }, group);\r\n        });\r\n    }\r\n    /**\r\n     * This adds an application to a tabgroup\r\n     * @param {TabAPIInteractionMessage} applicationToAttach The application to be attached\r\n     * @param {TabGroup} tabGroup The tab group to attach the application to\r\n     */\r\n    _add(applicationToAttach, tabGroup) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!applicationToAttach) {\r\n                console.error(\"No application has been passed in\");\r\n                return;\r\n            }\r\n            if (!tabGroup) {\r\n                console.error(\"No tab group has been passed in\");\r\n                return;\r\n            }\r\n            const tabPackage = {\r\n                tabID: { uuid: applicationToAttach.uuid, name: applicationToAttach.name },\r\n                tabProps: applicationToAttach.properties\r\n            };\r\n            const existingTab = yield this.mTabService.getTab({ uuid: tabPackage.tabID.uuid, name: tabPackage.tabID.name });\r\n            if (existingTab) {\r\n                if (existingTab.tabGroup === tabGroup) {\r\n                    console.error(\"Error:  Tab already exists in this tab group!\");\r\n                    return;\r\n                }\r\n                yield existingTab.tabGroup.removeTab({ uuid: tabPackage.tabID.uuid, name: tabPackage.tabID.name }, false, true);\r\n            }\r\n            const addedTab = yield tabGroup.addTab(tabPackage);\r\n            const align = addedTab.window.alignPositionToTabGroup();\r\n            const switchTab = tabGroup.switchTab({ uuid: tabPackage.tabID.uuid, name: tabPackage.tabID.name });\r\n            Promise.all([align, switchTab]);\r\n        });\r\n    }\r\n    /**\r\n     * Ejects a tab from tab group\r\n     * @param {TabAPIInteractionMessage} applicationToEject The application to eject from the tab group\r\n     * @param {TabGroup} tabGroup The tab group to eject from\r\n     */\r\n    _eject(applicationToEject, tabGroup) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!applicationToEject) {\r\n                console.error(\"No application has been passed in\");\r\n                return;\r\n            }\r\n            if (!tabGroup) {\r\n                console.error(\"No tab group has been passed in\");\r\n                return;\r\n            }\r\n            TabUtilities_1.ejectTab(this.mTabService, { name: applicationToEject.name, uuid: applicationToEject.uuid }, tabGroup);\r\n        });\r\n    }\r\n    /**\r\n     * Closes the tab and the application itself\r\n     * @param {TabAPIInteractionMessage} applicationToClose The application to close\r\n     * @param {TabGroup} tabGroup The group the application is within\r\n     */\r\n    _close(applicationToClose, tabGroup) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!applicationToClose) {\r\n                console.error(\"No application has been passed in\");\r\n                return;\r\n            }\r\n            if (!tabGroup) {\r\n                console.error(\"No tab group has been passed in\");\r\n                return;\r\n            }\r\n            tabGroup.removeTab({ uuid: applicationToClose.uuid, name: applicationToClose.name }, true, true);\r\n        });\r\n    }\r\n    /**\r\n     * Activates the tab being selected and brings it to the front\r\n     * @param {TabAPIInteractionMessage} applicationToActivate The application to be activated\r\n     * @param {TabGroup} tabGroup The tab group the application is in\r\n     */\r\n    _activate(applicationToActivate, tabGroup) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!applicationToActivate) {\r\n                console.error(\"No application has been passed in\");\r\n                return;\r\n            }\r\n            if (!tabGroup) {\r\n                console.error(\"No tab group has been passed in\");\r\n                return;\r\n            }\r\n            tabGroup.switchTab({ name: applicationToActivate.name, uuid: applicationToActivate.uuid });\r\n        });\r\n    }\r\n    /**\r\n     * Updates the properties of the tab\r\n     * @param {TabAPIInteractionMessage} tabToUpdate Holds information about the tab to update and its new properties\r\n     * @param {TabGroup} tabGroup The group the tab is in\r\n     */\r\n    _updateTabProperties(tabToUpdate, tabGroup) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!tabToUpdate) {\r\n                console.error(\"No tab to update has beed passed in\");\r\n                return;\r\n            }\r\n            if (!tabGroup) {\r\n                console.error(\"No tab group has been passed in\");\r\n                return;\r\n            }\r\n            if (!tabToUpdate.properties) {\r\n                console.error(\"No tab properties to update\");\r\n                return;\r\n            }\r\n            const tab = tabGroup.getTab({ uuid: tabToUpdate.uuid, name: tabToUpdate.name });\r\n            if (!tab) {\r\n                console.error(\"No tab has been found\");\r\n                return;\r\n            }\r\n            tab.updateTabProperties(tabToUpdate.properties);\r\n        });\r\n    }\r\n}\r\nexports.TabAPIActionProcessor = TabAPIActionProcessor;\r\n\n\n//# sourceURL=webpack:///./src/provider/tabbing/TabAPIActionProcessor.ts?");

/***/ }),

/***/ "./src/provider/tabbing/TabGroup.ts":
/*!******************************************!*\
  !*** ./src/provider/tabbing/TabGroup.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst uuid_1 = __webpack_require__(/*! uuid */ \"./node_modules/uuid/index.js\");\r\nconst APITypes_1 = __webpack_require__(/*! ../../shared/APITypes */ \"./src/shared/APITypes.ts\");\r\nconst GroupWindow_1 = __webpack_require__(/*! ./GroupWindow */ \"./src/provider/tabbing/GroupWindow.ts\");\r\nconst Tab_1 = __webpack_require__(/*! ./Tab */ \"./src/provider/tabbing/Tab.ts\");\r\nconst TabService_1 = __webpack_require__(/*! ./TabService */ \"./src/provider/tabbing/TabService.ts\");\r\n/**\r\n * Handles functionality for the TabSet\r\n */\r\nclass TabGroup {\r\n    /**\r\n     * Constructor for the TabGroup Class.\r\n     * @param {TabWindowOptions} windowOptions\r\n     */\r\n    constructor(windowOptions) {\r\n        this.ID = uuid_1.v4();\r\n        this._tabs = [];\r\n        this._window = new GroupWindow_1.GroupWindow(windowOptions, this);\r\n    }\r\n    /**\r\n     * Initializes the async methods required for the TabGroup Class.\r\n     */\r\n    init() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this._window.init();\r\n        });\r\n    }\r\n    /**\r\n     * Adds a Tab to the tabset.\r\n     * @param {TabPackage} tabPackage The package containing uuid, name, tabProperties of the tab to be added.\r\n     * @returns {Tab} The created tab.\r\n     */\r\n    addTab(tabPackage) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const tab = new Tab_1.Tab(tabPackage, this);\r\n            this._tabs.push(tab);\r\n            yield tab.init();\r\n            if (this._tabs.length > 1) {\r\n                tab.window.hide();\r\n            }\r\n            else {\r\n                const tabOpts = yield tab.window.getWindowOptions();\r\n                if (tabOpts.opacity === 0) {\r\n                    tab.window.show();\r\n                }\r\n            }\r\n            return tab;\r\n        });\r\n    }\r\n    /**\r\n     * Realigns all tab windows of the group to the position of the tab set window.\r\n     */\r\n    realignApps() {\r\n        return Promise.all(this._tabs.map(tab => {\r\n            tab.window.alignPositionToTabGroup();\r\n        }));\r\n    }\r\n    /**\r\n     * Deregisters the Tab from tabbing altogether.\r\n     * @param ID ID (uuid, name) of the Tab to deregister.\r\n     */\r\n    deregisterTab(ID) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const tab = this.getTab(ID);\r\n            yield this.removeTab(ID, false, true);\r\n            if (tab) {\r\n                tab.window.updateWindowOptions({ frame: true, opacity: 1.0 });\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Removes a specified tab from the tab group.\r\n     * @param {TabIdentifier} tabID The Tabs ID to remove.\r\n     * @param {boolean} closeApp Flag to force close the tab window or not.\r\n     * @param {boolean} closeGroupWindowCheck Flag to check if we should close the tab set window if there are no more tabs.\r\n     */\r\n    removeTab(tabID, closeApp, closeGroupWindowCheck = false) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const index = this.getTabIndex(tabID);\r\n            if (index === -1) {\r\n                return;\r\n            }\r\n            const tabIndex = this._tabs[index];\r\n            this._tabs.splice(index, 1);\r\n            yield tabIndex.remove(closeApp);\r\n            if (closeGroupWindowCheck) {\r\n                if (this._tabs.length === 0) {\r\n                    yield TabService_1.TabService.INSTANCE.removeTabGroup(this.ID, true);\r\n                    return;\r\n                }\r\n            }\r\n            if (this._tabs.length > 0) {\r\n                yield this.switchTab(null);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Switches the active Tab in the group. Hides current active window.\r\n     * @param {TabIdentifier} ID The ID of the tab to set as active.\r\n     * @param {boolean} hideActiveTab Flag if we should hide the current active tab.\r\n     */\r\n    switchTab(ID, hideActiveTab = true) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!ID) {\r\n                ID = { uuid: this._tabs[0].ID.uuid, name: this._tabs[0].ID.name };\r\n            }\r\n            const tab = this.getTab(ID);\r\n            if (tab && tab !== this._activeTab) {\r\n                yield tab.window.show();\r\n                if (this._activeTab) {\r\n                    this._activeTab.window.hide();\r\n                }\r\n                tab.window.finWindow.bringToFront();\r\n                this.setActiveTab(tab);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Removes all tabs from this tab set.\r\n     * @param closeApp Flag if we should close the tab windows.\r\n     */\r\n    removeAllTabs(closeApp) {\r\n        const refArray = this._tabs.slice();\r\n        const refArrayMap = refArray.map(tab => {\r\n            this.removeTab(tab.ID, closeApp, true);\r\n        });\r\n        return Promise.all(refArrayMap);\r\n    }\r\n    /**\r\n     * Gets the tab with the specified identifier\r\n     * @param tabID The tab identifier\r\n     */\r\n    getTab(tabID) {\r\n        return this.tabs.find((tab) => {\r\n            return tab.ID.uuid === tabID.uuid && tab.ID.name === tabID.uuid;\r\n        });\r\n    }\r\n    /**\r\n     * Sets the active tab.  Does not switch tabs or hide/show windows.\r\n     * @param {Tab} tab The Tab to set as active.\r\n     */\r\n    setActiveTab(tab) {\r\n        this._activeTab = tab;\r\n        fin.desktop.InterApplicationBus.send(fin.desktop.Application.getCurrent().uuid, this.ID, APITypes_1.TabApiEvents.TABACTIVATED, tab.ID);\r\n    }\r\n    /**\r\n     * Finds the index of the specified Tab in the array.\r\n     * @param tabID The ID of the Tab.\r\n     * @returns {number} Index Number.\r\n     */\r\n    getTabIndex(tabID) {\r\n        return this.tabs.findIndex((tab) => {\r\n            return tab.ID.uuid === tabID.uuid && tab.ID.name === tabID.uuid;\r\n        });\r\n    }\r\n    /**\r\n     * Returns the current active tab of the tab set.\r\n     * @returns {Tab} The Active Tab\r\n     */\r\n    get activeTab() {\r\n        return this._activeTab;\r\n    }\r\n    /**\r\n     * Returns the tab sets window.\r\n     * @returns {GroupWindow} The group window.\r\n     */\r\n    get window() {\r\n        return this._window;\r\n    }\r\n    /**\r\n     * Returns the tabs of this tab set.\r\n     * @returns {Tab[]} Array of tabs.\r\n     */\r\n    get tabs() {\r\n        return this._tabs;\r\n    }\r\n}\r\nexports.TabGroup = TabGroup;\r\n\n\n//# sourceURL=webpack:///./src/provider/tabbing/TabGroup.ts?");

/***/ }),

/***/ "./src/provider/tabbing/TabService.ts":
/*!********************************************!*\
  !*** ./src/provider/tabbing/TabService.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst DragWindowManager_1 = __webpack_require__(/*! ./DragWindowManager */ \"./src/provider/tabbing/DragWindowManager.ts\");\r\nconst EventHandler_1 = __webpack_require__(/*! ./EventHandler */ \"./src/provider/tabbing/EventHandler.ts\");\r\nconst SaveAndRestoreAPIProcessor_1 = __webpack_require__(/*! ./SaveAndRestoreAPIProcessor */ \"./src/provider/tabbing/SaveAndRestoreAPIProcessor.ts\");\r\nconst TabAPIActionProcessor_1 = __webpack_require__(/*! ./TabAPIActionProcessor */ \"./src/provider/tabbing/TabAPIActionProcessor.ts\");\r\nconst TabGroup_1 = __webpack_require__(/*! ./TabGroup */ \"./src/provider/tabbing/TabGroup.ts\");\r\nconst ZIndexer_1 = __webpack_require__(/*! ./ZIndexer */ \"./src/provider/tabbing/ZIndexer.ts\");\r\n/**\r\n * The overarching class for the Tab Service.\r\n */\r\nclass TabService {\r\n    /**\r\n     * Constructor of the TabService Class.\r\n     */\r\n    constructor() {\r\n        /**\r\n         * Handle to the ZIndexer\r\n         */\r\n        this._zIndexer = new ZIndexer_1.ZIndexer();\r\n        this._tabGroups = [];\r\n        this._dragWindowManager = new DragWindowManager_1.DragWindowManager();\r\n        this._dragWindowManager.init();\r\n        this._eventHandler = new EventHandler_1.EventHandler(this);\r\n        this.mTabApiEventHandler = new TabAPIActionProcessor_1.TabAPIActionProcessor(this);\r\n        this.mTabApiEventHandler.init();\r\n        this.mSaveAndRestoreEventHandler = new SaveAndRestoreAPIProcessor_1.SaveAndRestoreAPIProcessor(this);\r\n        this.mSaveAndRestoreEventHandler.init();\r\n        TabService.INSTANCE = this;\r\n    }\r\n    /**\r\n     * Creates a new tab group\r\n     * @param {TabWindowOptions} WindowOptions Window Options used to create the tab group window (positions, dimensions, url, etc...)\r\n     * @returns {TabGroup} TabGroup\r\n     */\r\n    addTabGroup(windowOptions) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const group = new TabGroup_1.TabGroup(windowOptions);\r\n            yield group.init();\r\n            this._tabGroups.push(group);\r\n            return group;\r\n        });\r\n    }\r\n    /**\r\n     * Removes the tab group from the service and optionally closes all the groups tab windows.\r\n     * @param ID ID of the tab group to remove.\r\n     * @param closeApps Flag if we should close the groups tab windows.\r\n     */\r\n    removeTabGroup(ID, closeApps) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const groupIndex = this._getGroupIndex(ID);\r\n            if (groupIndex !== -1) {\r\n                const group = this._tabGroups[groupIndex];\r\n                yield group.removeAllTabs(closeApps);\r\n                yield group.window.close(true);\r\n                this._tabGroups.splice(groupIndex, 1);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Returns a tab group searched by its ID.\r\n     * @param ID ID of the tab group to find.\r\n     * @returns {TabGroup | undefined} TabGroup\r\n     */\r\n    getTabGroup(ID) {\r\n        return this._tabGroups.find((group) => {\r\n            return group.ID === ID;\r\n        });\r\n    }\r\n    /**\r\n     * Returns a tab group searched by a tab it contains.\r\n     * @param ID ID of the tab group to find.\r\n     * @returns {TabGroup | undefined} Tabgroup\r\n     */\r\n    getTabGroupByApp(ID) {\r\n        return this._tabGroups.find((group) => {\r\n            return group.tabs.some((tab) => {\r\n                const tabID = tab.ID;\r\n                return tabID.name === ID.name && tabID.uuid === ID.uuid;\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Returns an individual Tab.\r\n     * @param ID ID of the tab to get.\r\n     */\r\n    getTab(ID) {\r\n        const group = this.getTabGroupByApp(ID);\r\n        if (group) {\r\n            return group.getTab(ID);\r\n        }\r\n        return;\r\n    }\r\n    /**\r\n     * Checks for any windows that is under a specific point.\r\n     * @param {number} x X Coordinate\r\n     * @param {number} y Y Coordinate\r\n     * @returns {TabGroup | null}\r\n     */\r\n    isPointOverTabGroup(x, y) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const groupTabBounds = yield Promise.all(this._tabGroups.map((group) => __awaiter(this, void 0, void 0, function* () {\r\n                const activeTabBoundsP = group.activeTab.window.getWindowBounds();\r\n                const groupBoundsP = group.window.getWindowBounds();\r\n                const [activeTabBounds, groupBounds] = yield Promise.all([activeTabBoundsP, groupBoundsP]);\r\n                return {\r\n                    group,\r\n                    top: groupBounds.top,\r\n                    left: groupBounds.left,\r\n                    width: groupBounds.width,\r\n                    height: groupBounds.height + activeTabBounds.height\r\n                };\r\n            })));\r\n            const result = groupTabBounds.filter(group => {\r\n                return x > group.left && x < group.width + group.left && y > group.top && y < group.top + group.height;\r\n            });\r\n            if (result) {\r\n                const topOrdered = this._zIndexer.getTop(result.map(group => {\r\n                    return { uuid: group.group.activeTab.ID.uuid, name: group.group.activeTab.ID.name };\r\n                }));\r\n                if (topOrdered) {\r\n                    const f = result.find(g => {\r\n                        return g.group.activeTab.ID.uuid === topOrdered[0].uuid && g.group.activeTab.ID.name === topOrdered[0].name;\r\n                    });\r\n                    if (f) {\r\n                        return f.group;\r\n                    }\r\n                }\r\n            }\r\n            return null;\r\n        });\r\n    }\r\n    /**\r\n     * Returns the array index of a tab group.\r\n     * @param ID ID of the tab group to search.\r\n     * @returns {number} Index number.\r\n     */\r\n    _getGroupIndex(ID) {\r\n        return this._tabGroups.findIndex((tab) => {\r\n            return tab.ID === ID;\r\n        });\r\n    }\r\n    /**\r\n     * Returns the DragWindowManager instance.\r\n     * @returns {DragWindowManager} DragWindowManager\r\n     */\r\n    get dragWindowManager() {\r\n        return this._dragWindowManager;\r\n    }\r\n    /**\r\n     * Returns the Tab Group Array\r\n     * @returns {TabGroup[]} Tab Groups Array\r\n     */\r\n    get tabGroups() {\r\n        return this._tabGroups;\r\n    }\r\n}\r\nexports.TabService = TabService;\r\n\n\n//# sourceURL=webpack:///./src/provider/tabbing/TabService.ts?");

/***/ }),

/***/ "./src/provider/tabbing/TabUtilities.ts":
/*!**********************************************!*\
  !*** ./src/provider/tabbing/TabUtilities.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Ejects or moves a tab/tab group based criteria passed in.\r\n *\r\n * 1. If we receive a screenX & screenY position, we check if a tab group + tab app is under that point.  If there is a window under that point we check if their URLs match and if they do, we allow tabbing to occur.  If not, we cancel out.\r\n *\r\n *\r\n * 2. If we receive a screenX & screenY position, we check if a tab group + tab app is under that point.  If there is not a window under that point we create a new tab group + tab\r\n * \tat the screenX & screenY provided if there are more than 1 tabs in the original group. If there is only one tab we move the window.\r\n *\r\n *\r\n * 3. If we dont receive a screenX & screenY position, we create a new tabgroup + tab at the app windows existing position.\r\n *\r\n * @param tabService The service itself which holds the tab groups\r\n * @param message Application or tab to be ejected\r\n */\r\nfunction ejectTab(tabService, message, tabGroup) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        // Get the tab that was ejected.\r\n        const ejectedTab = tabGroup ? tabGroup.getTab({ name: message.name, uuid: message.uuid }) : tabService.getTab({ uuid: message.uuid, name: message.name });\r\n        // if the tab is not valid then return out of here!\r\n        if (!ejectedTab) {\r\n            return;\r\n        }\r\n        // Default result is null (no window)\r\n        let isOverTabWindowResult = null;\r\n        // If we have a screenX & screenY we check if there is a tab group + tab window underneath\r\n        if (message.screenX && message.screenY) {\r\n            isOverTabWindowResult = yield tabService.isPointOverTabGroup(message.screenX, message.screenY);\r\n        }\r\n        // If there is a window underneath our point\r\n        if (isOverTabWindowResult) {\r\n            // If the window underneath our point is not the group we're ejecting from.\r\n            if (isOverTabWindowResult !== ejectedTab.tabGroup) {\r\n                // If the window underneath our point has the same URL as the ejecting group\r\n                if (isOverTabWindowResult.window.initialWindowOptions.url === ejectedTab.tabGroup.window.initialWindowOptions.url) {\r\n                    // Remove the tab from the ejecting group\r\n                    yield ejectedTab.tabGroup.removeTab(ejectedTab.ID, false, true);\r\n                    // Add the tab to the window underneath our point\r\n                    const tab = yield isOverTabWindowResult.addTab({ tabID: ejectedTab.ID });\r\n                    // Align the app window to the new tab group (window underneath)\r\n                    yield tab.window.alignPositionToTabGroup();\r\n                    // Switch to the added tab in the new group to show the proper window\r\n                    isOverTabWindowResult.switchTab(ejectedTab.ID);\r\n                }\r\n                else {\r\n                    // If we the two group URLs dont match then we dont allow tabbing!\r\n                    console.warn(\"Cannot tab - mismatched group Urls!\");\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // If we have no window underneath our point...\r\n            // Get the original options for the ejecting group (URL, height, etc) to be used for the new tab group.\r\n            const originalOptions = ejectedTab.tabGroup.window.initialWindowOptions;\r\n            // Get the bounds of the ejecting tabgroup\r\n            const [tabGroupBounds] = yield Promise.all([ejectedTab.tabGroup.window.getWindowBounds()]);\r\n            // If we have a screenX & screen (but no window undearneath, obviously)\r\n            if (message.screenX && message.screenY) {\r\n                // If our ejecting tab is the last one in the tab group\r\n                if (ejectedTab.tabGroup.tabs.length === 1) {\r\n                    // We just move the window instead of reinitializing\r\n                    ejectedTab.tabGroup.window.moveTo(message.screenX, message.screenY);\r\n                }\r\n                else {\r\n                    // If there are other tabs in the ejecting tab group\r\n                    // Remove the tab\r\n                    yield ejectedTab.tabGroup.removeTab(ejectedTab.ID, false, true);\r\n                    // Reinitialize a new tab group + tab using the ejecting groups options\r\n                    initializeTabbing({\r\n                        url: originalOptions.url,\r\n                        height: originalOptions.height,\r\n                        width: tabGroupBounds.width,\r\n                        screenX: message.screenX,\r\n                        screenY: message.screenY\r\n                    }, ejectedTab.ID.uuid, ejectedTab.ID.name, tabService);\r\n                }\r\n            }\r\n            else {\r\n                // If we have no screenX & screenY and no window underneath (obviously...)\r\n                // Remove the tab from the ejecting group\r\n                yield ejectedTab.tabGroup.removeTab(ejectedTab.ID, false, true);\r\n                // Reinitialize the tab at the app windows existing location\r\n                initializeTabbing({ url: originalOptions.url, height: originalOptions.height, width: tabGroupBounds.width }, ejectedTab.ID.uuid, ejectedTab.ID.name, tabService);\r\n            }\r\n        }\r\n    });\r\n}\r\nexports.ejectTab = ejectTab;\r\n/**\r\n * Creates a new tab group and adds a tab to it.\r\n * @param message Tab window options\r\n * @param uuid the uuid of the application to add as a tab\r\n * @param name the name of the application to add as a tab\r\n * @param tabService The tab service\r\n */\r\nfunction initializeTabbing(message, uuid, name, tabService) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        if (tabService.getTabGroupByApp({ name, uuid })) {\r\n            console.error(\"This window has already been initialised with a tab\", { name, uuid });\r\n            return;\r\n        }\r\n        const group = yield tabService.addTabGroup(message);\r\n        const tab = yield group.addTab({ tabID: { uuid, name } });\r\n        if (message.screenX && message.screenY) {\r\n            // if we are provided coords then we tab group is created at them so we need to bring the app window to group.\r\n            yield tab.window.alignPositionToTabGroup();\r\n        }\r\n        else {\r\n            // if no coords then its safe to assume we need to move group window to app window.\r\n            yield group.window.alignPositionToApp(tab.window);\r\n        }\r\n        // shows the tab group window because it is default hidden\r\n        group.window.finWindow.show();\r\n        // Switch tab on group to make our added tab the active one\r\n        group.switchTab({ uuid, name });\r\n    });\r\n}\r\nexports.initializeTabbing = initializeTabbing;\r\n\n\n//# sourceURL=webpack:///./src/provider/tabbing/TabUtilities.ts?");

/***/ }),

/***/ "./src/provider/tabbing/TabWindow.ts":
/*!*******************************************!*\
  !*** ./src/provider/tabbing/TabWindow.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst asyncWindow_1 = __webpack_require__(/*! ./asyncWindow */ \"./src/provider/tabbing/asyncWindow.ts\");\r\n/**\r\n * Handles the window for the Tab\r\n */\r\nclass TabWindow extends asyncWindow_1.AsyncWindow {\r\n    /**\r\n     * Constructor of the TabWindow Class.\r\n     * @param tab Tab that the window belongs to.\r\n     * @param tabID Identifier of the tab app window (uuid, name)\r\n     */\r\n    constructor(tab, tabID) {\r\n        super();\r\n        /**\r\n         * The initial options of the tab window.\r\n         */\r\n        this._initialWindowOptions = {};\r\n        /**\r\n         * The intitial bounds of the tab window.\r\n         */\r\n        this._initialWindowBounds = {};\r\n        this._tab = tab;\r\n        this._tabGroup = tab.tabGroup;\r\n        this._window = fin.desktop.Window.wrap(tabID.uuid, tabID.name);\r\n    }\r\n    /**\r\n     * Initializes the async methods required for the TabWindow class.\r\n     */\r\n    init() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            [this._initialWindowOptions, this._initialWindowBounds] = yield Promise.all([this.getWindowOptions(), this.getWindowBounds()]);\r\n            // @ts-ignore resizeRegion.sides is valid.  Its not in the type file.\r\n            this.updateWindowOptions({ frame: false, resizeRegion: { sides: { top: false } } });\r\n            this._createWindowEventListeners();\r\n        });\r\n    }\r\n    /**\r\n     * Hides the tab window.\r\n     */\r\n    hide() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this.updateWindowOptions({\r\n                opacity: 0\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Shows the tab window. If the window is minimized we will restore it.\r\n     */\r\n    show() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const state = yield this.getState();\r\n            if (state === \"minimized\") {\r\n                this._window.restore();\r\n            }\r\n            this._window.updateOptions({\r\n                opacity: 1\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Aligns the position of this tab window to the position of the tab set group window.\r\n     */\r\n    alignPositionToTabGroup() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const groupWindow = this._tab.tabGroup.window;\r\n            const groupActiveTab = this._tab.tabGroup.activeTab;\r\n            const tabGroupBoundsP = groupWindow.getWindowBounds();\r\n            const tabBoundsP = groupActiveTab ? groupActiveTab.window.getWindowBounds() : this.getWindowBounds();\r\n            const [tabGroupBounds, tabBounds] = yield Promise.all([tabGroupBoundsP, tabBoundsP]);\r\n            const resize = new Promise((res, rej) => {\r\n                this._window.resizeTo(tabGroupBounds.width, tabBounds.height, \"top-left\", res, rej);\r\n            });\r\n            const moveTo = new Promise((res, rej) => {\r\n                this._window.moveTo(tabGroupBounds.left, tabGroupBounds.top + tabGroupBounds.height, res, rej);\r\n            });\r\n            yield Promise.all([resize, moveTo]);\r\n            this._window.joinGroup(groupWindow.finWindow);\r\n        });\r\n    }\r\n    /**\r\n     * Initializes event listeners for this windows events.\r\n     */\r\n    _createWindowEventListeners() {\r\n        this._window.addEventListener(\"minimized\", this._onMinimize.bind(this));\r\n        this._window.addEventListener(\"maximized\", this._onMaximize.bind(this));\r\n        this._window.addEventListener(\"restored\", this._onRestore.bind(this));\r\n        this._window.addEventListener(\"closed\", this._onClose.bind(this));\r\n        this._window.addEventListener(\"focused\", this._onFocus.bind(this));\r\n        this._window.addEventListener(\"bounds-changed\", this._onBoundsChanged.bind(this));\r\n    }\r\n    /**\r\n     * Handles when the window is minimized.  If the window being minimized is the active tab, we will minimize the tab group as well.\r\n     */\r\n    _onMinimize() {\r\n        if (this._tab === this._tabGroup.activeTab) {\r\n            this._tabGroup.window.minimizeGroup();\r\n        }\r\n    }\r\n    /**\r\n     * Handles when the window is maximized. This will maximize the tab group.\r\n     */\r\n    _onMaximize() {\r\n        this._tabGroup.window.maximizeGroup();\r\n    }\r\n    /**\r\n     * Handles when the window is restored.  If this is the active tab then we will restore the entire tab group.  If not we will set the active tab to the window restored, then restore the tab group.\r\n     */\r\n    _onRestore() {\r\n        if (this._tab === this._tabGroup.activeTab) {\r\n            this._tabGroup.window.restoreGroup();\r\n        }\r\n        else {\r\n            this._tabGroup.switchTab(this._tab.ID);\r\n            this._tabGroup.window.restoreGroup();\r\n        }\r\n    }\r\n    /**\r\n     * Handles when the window is closed.  This will remove it from the tab group.\r\n     */\r\n    _onClose() {\r\n        this._tabGroup.removeTab(this._tab.ID, false, true);\r\n    }\r\n    /**\r\n     * Handles when the window is focused.  If we are not the active window we will set the window being focused to be the active.\r\n     */\r\n    _onFocus() {\r\n        if (this._tab !== this._tabGroup.activeTab) {\r\n            this._tabGroup.switchTab(this._tab.ID);\r\n        }\r\n        this._tabGroup.window.finWindow.bringToFront();\r\n    }\r\n    /**\r\n     * Handles when the windows bounds have changed.  If we are the active tab + maximized state then we will call a restore on the tab group to shrink us back down to before maximized size.\r\n     */\r\n    _onBoundsChanged() {\r\n        if (this._tab === this._tabGroup.activeTab) {\r\n            if (this._tabGroup.window.isMaximized) {\r\n                this._tabGroup.window.restoreGroup();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Returns the window options set during initialization.\r\n     * @returns {fin.WindowOptions} Fin.WindowOptions\r\n     */\r\n    get windowOptions() {\r\n        return this._initialWindowOptions;\r\n    }\r\n}\r\nexports.TabWindow = TabWindow;\r\n\n\n//# sourceURL=webpack:///./src/provider/tabbing/TabWindow.ts?");

/***/ }),

/***/ "./src/provider/tabbing/ZIndexer.ts":
/*!******************************************!*\
  !*** ./src/provider/tabbing/ZIndexer.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Keeps track of window Z-indexes.  Currently a POC!\r\n */\r\nclass ZIndexer {\r\n    /**\r\n     * Constructor of the ZIndexer class.\r\n     */\r\n    constructor() {\r\n        /**\r\n         * The array of z-indexes of windows + IDs\r\n         */\r\n        this._stack = [];\r\n        if (ZIndexer.INSTANCE) {\r\n            return ZIndexer.INSTANCE;\r\n        }\r\n        fin.desktop.Application.getCurrent().addEventListener(\"window-created\", win => {\r\n            // @ts-ignore\r\n            const w = fin.desktop.Window.wrap(fin.desktop.Application.getCurrent().uuid, win.name);\r\n            this._addEventListeners(w);\r\n        });\r\n        fin.desktop.System.addEventListener(\"application-started\", ev => {\r\n            // @ts-ignore\r\n            const app = fin.desktop.Application.wrap(ev.uuid);\r\n            const appWin = app.getWindow();\r\n            this._addEventListeners(appWin);\r\n            app.addEventListener(\"window-created\", win => {\r\n                // @ts-ignore\r\n                const w = fin.desktop.Window.wrap(app.uuid, win.name);\r\n                this._addEventListeners(w);\r\n            });\r\n        });\r\n        ZIndexer.INSTANCE = this;\r\n    }\r\n    /**\r\n     * Updates the windows index in the stack and sorts array.\r\n     * @param ID ID of the window to update (uuid, name)\r\n     */\r\n    update(ID) {\r\n        const time = new Date().valueOf();\r\n        const index = this._stack.find(i => {\r\n            return ID.uuid === i.ID.uuid && ID.name === i.ID.name;\r\n        });\r\n        if (index) {\r\n            index.timestamp = time;\r\n        }\r\n        else {\r\n            this._stack.push({ ID, timestamp: time });\r\n        }\r\n        this._stack.sort((a, b) => {\r\n            return b.timestamp - a.timestamp;\r\n        });\r\n    }\r\n    /**\r\n     * Returns order of zindexs for a set of window IDs.  Order is from top to bottom.\r\n     * @param {TabIdentifier[]} ids Array of IDs to get order of.\r\n     * @return {TabIdentifier[] | null} Array of TabIdentifiers or null\r\n     */\r\n    getTop(ids) {\r\n        const resArray = [];\r\n        this._stack.forEach(idx => {\r\n            const result = ids.find(idsidx => {\r\n                return idx.ID.uuid === idsidx.uuid && idx.ID.name === idsidx.name;\r\n            });\r\n            if (result)\r\n                resArray.push(result);\r\n        });\r\n        return resArray.length > 0 ? resArray : null;\r\n    }\r\n    /**\r\n     * Creates window event listeners on a specified window.\r\n     * @param win Window to add the event listeners to.\r\n     */\r\n    _addEventListeners(win) {\r\n        win.addEventListener(\"focused\", () => {\r\n            // @ts-ignore\r\n            this.update({ uuid: win.uuid, name: win.name });\r\n        });\r\n        win.addEventListener(\"shown\", () => {\r\n            // @ts-ignore\r\n            this.update({ uuid: win.uuid, name: win.name });\r\n        });\r\n        win.addEventListener(\"bounds-changed\", () => {\r\n            // @ts-ignore\r\n            this.update({ uuid: win.uuid, name: win.name });\r\n        });\r\n    }\r\n    /**\r\n     * Returns the array of indexes.\r\n     * @returns {ZIndex[]} ZIndex[]\r\n     */\r\n    get indexes() {\r\n        return this._stack;\r\n    }\r\n}\r\nexports.ZIndexer = ZIndexer;\r\n\n\n//# sourceURL=webpack:///./src/provider/tabbing/ZIndexer.ts?");

/***/ }),

/***/ "./src/provider/tabbing/asyncWindow.ts":
/*!*********************************************!*\
  !*** ./src/provider/tabbing/asyncWindow.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Contains promisified Openfin window functionality.\r\n */\r\nclass AsyncWindow {\r\n    /**\r\n     * Gets the Openfin window bounds.\r\n     * @returns {Promise<fin.WindowBounds>} A promise with the WindowBounds\r\n     */\r\n    getWindowBounds() {\r\n        return new Promise((res, rej) => {\r\n            this._window.getBounds(res, rej);\r\n        });\r\n    }\r\n    /**\r\n     * Resizes the window.\r\n     * @param {number} width New Window Width\r\n     * @param {number} height New Window Height\r\n     * @param {fin.OpenFinAnchor} anchor The Openfin Anchor Position (\"top-left\", etc...)\r\n     */\r\n    resizeTo(width, height, anchor) {\r\n        return new Promise((res, rej) => {\r\n            this._window.resizeTo(width, height, anchor, res, rej);\r\n        });\r\n    }\r\n    /**\r\n     * Updates the Openfin Window Options\r\n     * @param {fin.WindowOptions} options The Openfin Window Options to update.\r\n     */\r\n    updateWindowOptions(options) {\r\n        return new Promise((res, rej) => {\r\n            this._window.updateOptions(options, res, rej);\r\n        });\r\n    }\r\n    /**\r\n     * Returns the window options for the current window\r\n     * @returns {Promise<fin.WindowOptions>} A promsie with WindowOptions result\r\n     */\r\n    getWindowOptions() {\r\n        return new Promise((res, rej) => {\r\n            this._window.getOptions(res, rej);\r\n        });\r\n    }\r\n    /**\r\n     * Closes the Openfin Window.\r\n     * @param force Force close the window in case the window has a show-requested listener.\r\n     */\r\n    close(force) {\r\n        return new Promise((res, rej) => {\r\n            this._window.close(force, res, rej);\r\n        });\r\n    }\r\n    /**\r\n     * Returns the Openfin window state.\r\n     * @returns {Promise<string>}\r\n     */\r\n    getState() {\r\n        return new Promise((res, rej) => {\r\n            this._window.getState(res, rej);\r\n        });\r\n    }\r\n    /**\r\n     * Moves the window to a new position.\r\n     * @param {number} left X Coordinate to Move to.\r\n     * @param {number} top Y Coordinate to Move to.\r\n     */\r\n    moveTo(left, top) {\r\n        return new Promise((res, rej) => {\r\n            this._window.moveTo(left, top, res, rej);\r\n        });\r\n    }\r\n    /**\r\n     * Leaves the windows current group.\r\n     */\r\n    leaveGroup() {\r\n        return new Promise((res, rej) => {\r\n            this._window.leaveGroup(res, rej);\r\n        });\r\n    }\r\n    restore() {\r\n        return new Promise((res, rej) => {\r\n            this._window.restore(res, rej);\r\n        });\r\n    }\r\n    minimize() {\r\n        return new Promise((res, rej) => {\r\n            this._window.minimize(res, rej);\r\n        });\r\n    }\r\n    /**\r\n     * Returns the Openfin Window\r\n     */\r\n    get finWindow() {\r\n        return this._window;\r\n    }\r\n}\r\nexports.AsyncWindow = AsyncWindow;\r\n\n\n//# sourceURL=webpack:///./src/provider/tabbing/asyncWindow.ts?");

/***/ }),

/***/ "./src/provider/tabbing/index.ts":
/*!***************************************!*\
  !*** ./src/provider/tabbing/index.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst TabService_1 = __webpack_require__(/*! ./TabService */ \"./src/provider/tabbing/TabService.ts\");\r\nwindow.TabService = new TabService_1.TabService();\r\n\n\n//# sourceURL=webpack:///./src/provider/tabbing/index.ts?");

/***/ }),

/***/ "./src/shared/APITypes.ts":
/*!********************************!*\
  !*** ./src/shared/APITypes.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar TabApiEvents;\r\n(function (TabApiEvents) {\r\n    TabApiEvents[\"TABADDED\"] = \"TABADDED\";\r\n    TabApiEvents[\"TABREMOVED\"] = \"TABREMOVED\";\r\n    TabApiEvents[\"PROPERTIESUPDATED\"] = \"PROPERTIESUPDATED\";\r\n    TabApiEvents[\"TABACTIVATED\"] = \"TABACTIVATED\";\r\n})(TabApiEvents = exports.TabApiEvents || (exports.TabApiEvents = {}));\r\nvar AppApiEvents;\r\n(function (AppApiEvents) {\r\n    AppApiEvents[\"CLIENTINIT\"] = \"CLIENTINIT\";\r\n    AppApiEvents[\"TABBED\"] = \"TABBED\";\r\n    AppApiEvents[\"UNTABBED\"] = \"UNTABBED\";\r\n    AppApiEvents[\"DEREGISTER\"] = \"DEREGISTER\";\r\n})(AppApiEvents = exports.AppApiEvents || (exports.AppApiEvents = {}));\r\n/**\r\n * @description The action the tab client api will send to the service,\r\n * this will determine which action to execute on service side\r\n */\r\nvar TabAPIActions;\r\n(function (TabAPIActions) {\r\n    TabAPIActions[\"STARTDRAG\"] = \"STARTDRAG\";\r\n    TabAPIActions[\"ENDDRAG\"] = \"ENDDRAG\";\r\n    TabAPIActions[\"ADD\"] = \"ADD\";\r\n    TabAPIActions[\"EJECT\"] = \"EJECT\";\r\n    TabAPIActions[\"CLOSE\"] = \"CLOSE\";\r\n    TabAPIActions[\"ACTIVATE\"] = \"ACTIVATE\";\r\n    TabAPIActions[\"UPDATEPROPERTIES\"] = \"UPDATEPROPERTIES\";\r\n    TabAPIActions[\"INIT\"] = \"TABINIT\";\r\n})(TabAPIActions = exports.TabAPIActions || (exports.TabAPIActions = {}));\r\nvar TabAPIWindowActions;\r\n(function (TabAPIWindowActions) {\r\n    TabAPIWindowActions[\"MAXIMIZE\"] = \"MAXIMIZEWINDOW\";\r\n    TabAPIWindowActions[\"MINIMIZE\"] = \"MINIMIZEWINDOW\";\r\n    TabAPIWindowActions[\"RESTORE\"] = \"RESTOREWINDOW\";\r\n    TabAPIWindowActions[\"CLOSE\"] = \"CLOSEWINDOW\";\r\n    TabAPIWindowActions[\"TOGGLEMAXIMIZE\"] = \"TOGGLEMAXIMIZE\";\r\n})(TabAPIWindowActions = exports.TabAPIWindowActions || (exports.TabAPIWindowActions = {}));\r\nvar SaveAndRestoreActions;\r\n(function (SaveAndRestoreActions) {\r\n    SaveAndRestoreActions[\"GETBLOB\"] = \"SARGETBLOB\";\r\n    SaveAndRestoreActions[\"SENDBLOB\"] = \"SARSENDBLOB\";\r\n})(SaveAndRestoreActions = exports.SaveAndRestoreActions || (exports.SaveAndRestoreActions = {}));\r\nvar SaveAndRestoreEvents;\r\n(function (SaveAndRestoreEvents) {\r\n    SaveAndRestoreEvents[\"GETBLOBRETURN\"] = \"SARRETURNBLOB\";\r\n})(SaveAndRestoreEvents = exports.SaveAndRestoreEvents || (exports.SaveAndRestoreEvents = {}));\r\n\n\n//# sourceURL=webpack:///./src/shared/APITypes.ts?");

/***/ })

/******/ });